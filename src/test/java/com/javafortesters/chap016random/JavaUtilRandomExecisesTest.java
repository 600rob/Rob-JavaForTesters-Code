package com.javafortesters.chap016random;

import org.junit.Assert;
import org.junit.Test;

import java.util.*;

import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.Assert.assertTrue;
//import static org.junit.Assert.*;

/**
 * Created by robert.hope on 05/09/2017.
 */
public class JavaUtilRandomExecisesTest {

    //create  a method to create 1000 random ints and verifiy that they are all within the max and min
    //integer limits
    @Test
    public void canConfirmNextIntLimits() {
        //create a Random object to use to call the nextInt method
        Random generate = new Random();

        //create a loop to create 1000 ranInts. assert that each is within MIN and MAX values
        //note ive declared my int values outside of the loop so they don't go out of scope outside the loop
        int ranInt;
        int i;
        for (i = 0; i < 1000; i++) {
            ranInt = generate.nextInt();
            assertThat(ranInt >= Integer.MIN_VALUE, is(true));
            assertThat(ranInt <= Integer.MAX_VALUE, is(true));
            System.out.println(ranInt);
        }
        System.out.println(i + " random ints generated");


    }

    @Test
    public void canConfirmNextIntLimitsRanBoolean() {
//create 1000 random booleans, verify that only 100 were created and double check the amount of each type generated

        //create a Random object to use to call the nextBoolean method
        Random generate = new Random();

        int i;
        boolean ranBool;
        int countTrue = 0;
        int countFalse = 0;

        for (i = 0; i < 1000; i++) {
            ranBool = generate.nextBoolean();
            if (ranBool == true)
                countTrue++;
            else
                countFalse++;
        }
        assertThat(countTrue > 0, is(true));
        assertThat(countFalse > 0, is(true));
        assertThat(countTrue + countFalse, is(1000));
        System.out.println(countTrue + " true booleans generated");
        System.out.println(countFalse + " false booleans generated");

    }


    @Test
    public void canConfirmNextIntLimitsLong() {
//create 1000 Random Longs, verify that then fall within the Max and Min Values
        Random generate = new Random();

        int i;
        long ranLong;

        for (i = 0; i < 1000; i++) {
            ranLong = generate.nextLong();
            assertThat(ranLong >= Long.MIN_VALUE, is(true));
            assertThat(ranLong <= Long.MAX_VALUE, is(true));
            System.out.println(ranLong);
        }
        System.out.println(i + " random Longs created");

    }


    @Test
    public void canConfirmNextIntLimitsFloat() {
//create random floats that fall between 0.0f and 1.0f
        Random generate = new Random();

        int i;
        float ranFloat;

        for (i = 0; i < 5; i++) {
            ranFloat = generate.nextFloat();
            assertThat(ranFloat >= 0.0f, is(true));
            assertThat(ranFloat <= 1.0f, is(true));
            System.out.println(ranFloat);
        }
        System.out.println(i + " random floats created");

    }

    @Test

    public void canConfirmNextDoublelimits() {
//create random doubles that fall between 0.0f and 1.0f
        Random generate = new Random();
        double ranDouble;

        for (int i = 0; i < 5; i++) {
            ranDouble = generate.nextDouble();
            assertThat(ranDouble >= 0.0d, is(true));
            assertThat(ranDouble <= 1.0d, is(true));
            System.out.println(ranDouble);
        }
    }

    @Test
    public void canGenerateRandomByte() {
        Random generate = new Random();

        for (int x = 0; x < 1000; x++) {
            // randomly generate a byte array between 0 and 99 length
            int arrayLength = generate.nextInt(100);
            byte[] bytes = new byte[arrayLength];
            generate.nextBytes(bytes);  // fill bytes with random data
            Assert.assertEquals(arrayLength, bytes.length);
            String viewbytes = new String(bytes);
            System.out.println(bytes.length + " - " + viewbytes);
        }
    }

    @Test

    public void canCreate1000NumbersBetween15And20() {
        //generate 1000 random numbers between 15 and 20. assert that all numbers, 15,16,17,18, 19 and 20 were created

        Random generate = new Random();

        int minValue = 15;
        int maxValue = 20;
        int i;
        //use a set to collect each number generated by out method. remember, a set does not allow
        //duplicates so it will ony store one of each number generated. Initially i tried to do this with
        // a regular array but it is not the best approach. also it does not expose the .contains method which will
        // allow me to verify each value iin the set

        Set<Integer> ranNums = new HashSet<>();

        for (i = 0; i < 1000; i++) {
            int ranNum = generate.nextInt(maxValue - minValue + 1) + minValue;
            assertThat(ranNum >= minValue, is(true));
            assertThat(ranNum <= maxValue, is(true));
            ranNums.add(ranNum);
        }
// we know that the set will only contain one of each value generated so we can assert against its size which is six
        assertThat(ranNums.size(), is(6));
        // we can also assert that the set contains each expected value.
        assertThat(ranNums.contains(15), is(true));
        assertThat(ranNums.contains(16), is(true));
        assertThat(ranNums.contains(17), is(true));
        assertThat(ranNums.contains(18), is(true));
        assertThat(ranNums.contains(19), is(true));
        assertThat(ranNums.contains(20), is(true));
        //finally, we can print the set
        System.out.println(ranNums);

    }

    @Test
    public void canCreate1000RandomGaussians() {
        //write an @ test method that creates 1000 random gaussian double values

        Random generate = new Random();
        int i;
        int sdcount1 = 0;
        int sdcount2 = 0;
        int sdcount3 = 0;
        int sdcount4 = 0;


        for (i = 0; i < 1000; i++) {
            double randomGaussian = generate.nextGaussian();

            //count the number of values generated that are in the 1, 2 3 and 4 deviation range
            if (randomGaussian < 1.0d && randomGaussian > -1.0d) {
                sdcount1++;
            }

            if (randomGaussian < 2.0d && randomGaussian > -2.0d) {
                sdcount2++;
            }

            if (randomGaussian < 3.0d && randomGaussian > -3.0d) {
                sdcount3++;
            }

            if (randomGaussian < 4.0d && randomGaussian > -4.0d) {
                sdcount4++;
            }

        }
        //print the number of each deviation type
        System.out.println(sdcount1);
        System.out.println(sdcount2);
        System.out.println(sdcount3);
        System.out.println(sdcount4);

        //work out the number of each deviation range as a percentage
        // Dont forget to use the "f"suffix in the calculations as we need to deal with small-ish decimals
        // f stands for float!

        float sd1percentage = (sdcount1 / 1000f) * 100f;
        System.out.println("about 70% one std deviation = " + sd1percentage);

        float sd2percentage = (sdcount2 / 1000f) * 100f;
        System.out.println("about 95% one std deviation = " + sd2percentage);

        float sd3percentage = (sdcount3 / 1000f) * 100f;
        System.out.println("about 99% one std deviation = " + sd3percentage);

        float sd4percentage = (sdcount4 / 1000f) * 100f;
        System.out.println("about 99.9% one std deviation = " + sd4percentage);

        assertTrue(sd1percentage < sd2percentage);
    }

    //Write an @Test method which generates 1000 ages using
    // nextGaussian with a mean of 35 and a standard deviation of 5.
    // Count each age generated and output the sorted list of ages and counts to the console.

    @Test
    public void canGenerate1000AgesUsingDeviation() {
//I dont understand how this method works...need to go back over collections, specifically
        //maps and sorted sets to see if i can get a handle on this!
        Random generate = new Random();
        Map<Integer, Integer> ages =
                new HashMap<>();

        for (int x = 0; x < 1000; x++) {
            int age = (int) (generate.nextGaussian() * 5) + 35;


            int ageCount = 0;
            if (ages.containsKey(age)) {
                ageCount = ages.get(age);
            }
            ageCount++;
            ages.put(age, ageCount);
        }

        SortedSet<Integer> agesSorted = new TreeSet(ages.keySet());

        for (int age : agesSorted) {
            System.out.println(age + " : " + ages.get(age));
        }
    }


    @Test

    public void canGenerateRandomNumbersWithSeed() {
/*
Create an @Test method for the seed 1234567L and assert that:

nextInt = = 1042961893 then
nextLong = = -6749250865724111202L
continue the assertions and add:
nextDouble, nextGaussian, nextFloat, nextBoolean
Make sure you can re-run the method and you get the same ‘random’ numbers.

Note: in order to know which expected values we want to assert on, we need to run a system.out.printLn
 in order to work out what values we're looking for. we can then use those values in the assert statements
 */


        for (int i = 0; i < 10; i++) {
            Random generate = new Random(1234567L);

            assertThat(generate.nextInt(), is(1042961893));
            assertThat(generate.nextLong(), is(-6749250865724111202L));
            assertThat(generate.nextDouble(), is(0.44762832574617084));
            assertThat(generate.nextGaussian(), is(-0.11571220872310763));
            assertThat(generate.nextFloat(), is(0.33144182f));
            assertThat(generate.nextBoolean(), is(false));
        }
    }

    /* Generate a random String which is 100 characters long and contains chars ' ', and 'A' to 'Z'

     */

    @Test
    public void canConstructRandomString100CharsLong() {

        //set a String containing all required characters;

        String rndIndex = "ABCDEFGHIJKLMNOPQRSTUVWXYZ ";
        //we will want ot allocate random characters to a string
        // which is 100 chars long. do this using a StringBuilder object and an
        //appropriately sized loop
        StringBuilder builder = new StringBuilder();

        // create a Random object for random generation
        Random generate = new Random();

        for (int i = 0; i < 100; i++) {

            //Randomly select a character index position from the string using the string length as a seed
            int ranCharPosition = generate.nextInt(rndIndex.length());
            // use the random position to generate the random character
            char ranChar = rndIndex.charAt(ranCharPosition);
            //check our index position
            //System.out.println(ranCharPosition);
            //check our 'random'  char that corresponds to the above index position
            System.out.println(ranChar);

            //append each random char to the end of our stringBuilder object
            builder.append(ranChar);
        }
        //assert that we've built the correct length string
        assertThat(builder.toString().length(),is(100));
        assertTrue(builder.toString().length()==100);
        //check that the string contains each of the chars in the reference String
        assertTrue(builder.toString().matches("[A-Z ]+"));
        // print the random string-
        System.out.println(builder.toString());


    }
}





